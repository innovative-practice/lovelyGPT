  《 数据结构课程设计 》 实验报告 实验 1 ：   线性表的实现和操作                                     姓      名：              徐壮                            学      号：            21334129                           专      业：           网络工程                          实验时间 ：                                             指导老师 ：           薛梅婷             杭州电子科技大学 网络空间安全学院 一、实验目的 1.  线性表顺序存储结构的操作与案例的实现 2.  线性表链式存储结构的操作与应用 3.  栈 与队列的操作与应用 4.  串的操作与应用 实验内容 与实验结果 实验 1-1 1 .  实验内容 顺序表存储结构 ， 定义程序所需要的一些符号常量、线性表元素类型和顺序表存储结构，以及所需的库函数。根据定义的顺序表结构 （1） InitList ( SqList  &L)——构造一个空的顺序表表L，L的初始大小为MAXSIZE。 （2） ClearList ( SqList  &L)——将顺序表的数据清空。 （3）int  Listlength ( SqList  L)——返回L中数据元素个数。 （4） GetElem ( SqList  L, int  i ,  ElemType  &e)——用e返回L中第 i 个 数据元素的值， （5）int  LocateList ( SqList  L,  ElemType  e)——返回L中第1个与e相等的数据元素位序， （6） ListInsert ( SqList  &L, int  i ,  ElemType  e)——在L中的第 i 个 位置之前插入新的数据元素e （7） ListDelete ( SqList  &L, int  i ,  ElemType  &e )——删除L中的第 i 个 数据元素，用e返回其值，1≤ i ≤ L.length 。 （8） ListTraverse ( SqList  L)——利用 printf 函数依次输出L的每个数据元素的值。 线性表元素的集合运算将顺序表La和 Lb 看成2个集合，利用上述基本操作函数，分别编写出实现集合并、交、差运算的3个函数源码： 两个 有序表 的合并设La和 Lb 中的元素是非递减有序的，编写一个 有序表 合并，即Lc= La+Lb 的函数源码 去掉线性表中的重复多余的元素设Lc是一个有重复元素的顺序表，编写一个去掉顺序表中重复多余元素的函数源码  编写一个主函数main()，来检验上述应用函数是否正确， 2.  源程序代码（ *.CPP ） 见附件  1 .1-main.cpp   （见附件） 3.  运行结果 ( 1). 数据准备生成两个顺序表 L A,LB 并输出 (2 )   将顺序表 LA 和 LB 看成 2 个集合，分别调用集合并、交、差运算的 3 个函数，并在每个函数调用后输出 LA 的元素值，观察函数执行结果是否正确。 （ 3 ）因为 LA 和 LB 中的元素是非递减有序的，调用 有序表 合并的函数 MergeList ( SqList  La,  SqList   Lb ,  SqList  &Lc) ，并在函数调用后输出 LC 的元素值。 （ 4 ） MergeList 函数合并后的 有序表 LC 存在重复多余的元素，调用 Purge( SqList  &Lc) 去掉重复多余的元素，并在函数调用后输出 LC 的元素值。 实验 1-2 实验内容 单链表存储结构的定义 单链表基本操作函数实现 （ 1 ） InitList ( LinkList  &L) ——初始化单链表 L 。 （ 2 ） ClearList ( LinkList   &L) ——清空单链表。 （ 3 ） int  Listlength ( LinkList   L) —— 求单链表 的长度，即返回 L 中数据结点个数。 （ 4 ） GetElem ( LinkList   L, int  i ,  ElemType  &e) ——用 e 返回 L 中第 i 个 数据结点的值 （ 5 ） LNode  * LocateList ( LinkList   L,  ElemType  e) ——返回 L 中第 1 个与 e 相等的数据结点的地址（指针），若 e 不存在，则返回 NULL 。 （ 6 ） ListInsert ( LinkList   &L, int  i ,  ElemType  e) ——在 L 中的第 i 个 数据结点之前插入新的数据结点 e ， 1 ≤ i ≤ Listlength (L)+1 。 （ 7 ） ListDelete ( LinkList   &L, int  i ,  ElemType  &e ) ——删除 L 中的第 i 个 数据 j 结点，用 e 返回删除结点的值， 1 ≤ i ≤ Listlength (L) 。 （ 8 ） ListTraverse ( LinkList   L) ——利用 printf 函数依次输出 L 的每个数据结点的值。 将单链表 La 和 Lb 看成 2 个集合，利用上述基本操作函数，分别编写出实现集合并、交、差运算的 3 个函数源码 两个 有序表 的合并 去掉线性表中的重复多余的元素 编写一个主函数 main() ，来检验上述应用函数是否正确 2.  源程序代码（ *.CPP ） 见附件  1 . 2 -main.cpp   （见附件） 3.  运行结果 （ 1 ）数据准备。生成 2 个顺序表 LA 、 LB ，其数据元素分别为： LA=2 → 8 → 27 → 39 → 66 → 77 → 89 →∧ LB=6 → 18 → 27 → 59 → 65 → 77 → 89 → 120 → 140 →∧ 单链表生成后，以上述格式输出各元素值。 （ 2 ）将单链表 LA 和 LB 看成 2 个集合，分别调用集合并、交、差运算的 3 个函数，并在每个函数调用后输出 LA 的元素值，观察函数执行结果是否正确。 （ 3 ）因为 LA 和 LB 中的元素是非递减有序的，调用 有序表 合并的函数 MergeList (LA, LB, LC) ，并在函数调用后输出 LC 的元素值。 （ 4 ） MergeList 函数合并后的 有序表 LC 存在重复多余的元素，调用 Purge(LC) 去掉重复多余的元素，并在函数调用后输出 LC 的元素值。 实验 1- 3 1 .  实验内容 顺序 栈 和循环队列的存储结构和相关内容的定义 顺序 栈 基本操作函数的实现 根据定义的顺序 栈 结构，编写下列基本操作函数的 C/C++ 源代码： （ 1 ） InitStack ( SqStack  &S) ——利用 malloc 函数申请存储空间，构造一个空的顺序 栈 S ， S 的初始大小为 STACK_INIT_SIZE 。 （ 2 ） ClearStack ( SqStack   &S) ——将顺序 栈 数据清空。只需做 S.top = S.base 赋值操作即可。  （ 3 ） StackLength ( SqStack   S) ——返回 L 中数据元素个数。直接返回 S.top-S.base 的值即可。 （ 4 ） GetTop ( SqStack   S,  SElemType  &e) ——用 e 返回 栈 顶元素的值。  （ 5 ） Push( SqStack   &S,  SElemType  e) ——将数据 e 进 栈 。 （ 6 ） Pop( SqStack   &S,  SElemType  &e) ——将 栈 顶元素出 栈 ，用 e 返回其值。 循环队列基本操作函数的实现 根据定义的循环队列结构，编写下列基本操作函数的 C/C++ 源代码： （ 1 ） InitQueue ( SqQueue   &Q) ——利用 malloc 函数申请存储空间，构造一个空的循环队列 Q ， Q 的大小为 MAXQSIZE 。 （ 2 ） ClearQueue ( SqQueue   &Q) ——将循环队列数据清空。  （ 3 ） QueueLength ( SqQueue   Q) ——返回 Q 中数据元素个数。 （ 4 ） EnQueue ( SqQueue   &Q,  QElemType  e) ——数据 e 入队。 （ 5 ） DeQueue ( SqStack   &Q,  QElemType  &e) ——数据出队，用 e 返回其值。 （ 6 ） QueueEmpty ( SqQueue   Q) ——判对空。 （ 7 ） QueueFull ( SqQueue   Q) —— 判队满 。 应用案例  利用顺序 栈 的基本操作函数，编制一个将十进制整数 m 转换成 n 进制 (n=2 或 8) 整数的数制转换函数 Conversion( m,n ) 编一个函数 QueueReverse (Q) ，利用 栈 将将队列中的元素逆序重排， 即队头 元素变成队尾元素。 5.  主函数 main() （ 1 ）数制转换 输入一个十进制数 m ，调用 Conversion( m,n )  函数将 m 转换成二进制数和八进制数。 （ 2 ）循环队列操作 <1> 连续入队 9 个整数后，显示队列 Q 的 front 和 rear 的值； <2> 若再入队 1 个整数，显示此时队列的状态信息； <3> 连续出队 5 个整数，再入队 2 个整数，显示此时的队列 Q 的长度与 front 和 rear 的值； <4> 调用函数 QueueReverse (Q) ，将队列元素逆序重排，然后将队列元素出队并输出。 2.  源程序代码（ *.CPP ） 见附件  1 . 3 -main.cpp   （见附件） 3.  运行结果 （ 1 ）数制转换输入一个十进制数 m ，调用 Conversion( m,n )  函数将 m 转换成二进制数和八进制数。 （ 2 ）循环队列操作 <1> 连续入队 9 个整数后，显示队列 Q 的 front 和 rear 的值； <2> 若再入队 1 个整数，显示此时队列的状态信息； <3> 连续出队 5 个整数，再入队 2 个整数，显示此时的队列 Q 的长度与 front 和 rear 的值； <4> 调用函数 QueueReverse (Q) ，将队列元素逆序重排，然后将队列元素出队并输出。   实验 1- 4 1 .  实验内容 串的 堆分配 存储结构定义 串基本 操作函数的实现 编写下列基本操作函数的 C/C++ 源代码。 （ 1 ） StrAssign ( HString  & S,chars ) ——将字符串常量 chars 赋给串变量 S ； （ 2 ） StrCompare ( HSTring  S,  HString  T) ——比较串 S 与 T 的值   ，若 S>T,  则返回 1 ；若 S=T, 则返回 0 ；否则返回 -1 。 （ 3 ） StrLength ( HString  S) ——返回串 S 的长度。 （ 4 ） Concat ( HString  &S,  HString  T1,  HString  T2) ——将串 T1 和 T2 连接在一起 赋给串变量 S 。 （ 5 ） SubString ( HString  &sub,  HString  S, int pos, int  len ) ——用 Sub 返回串 S 的第 pos 个 字符起长度为 len 的子串， 1 ≤  pos  ≤ StrLength (S) ， 1 ≤ len ≤ StrLength (S)-pos+1 （ 6 ） StrTraverse ( HString  S) ——遍历（输出）字符串 S 中的各个字符。 串其他 操作函数的实现  利用上述串的基本操作函数，编制下列串的操作函数。 （ 1 ） StrCopy ( HString  &S,  HString  T) ——将串 T 赋给串 S 。若使用 堆分配 存储结构，可利用 Concat () 函数实现。若使用 堆分配 存储结构，则需针对存储结构操作。 （ 2 ） Index( HString  S,  HString  T, int pos) ——返回串 T 在串 S 中第 pos 个 字符开始出现的位置， 若串 T 不是串 S 的子串，则返回 0 。 1 ≤  pos  ≤ StrLength (S) 。利用 SubString () 和 StrCompare () 实现。 （ 3 ） Replace( HString  &S,  HString  T1,  HString  T2) ——将 S 串中所有 的子串 T1 用串 T2 代替。利用 SubString () 、 StrCompare () 和 Concat () 实现。 （ 4 ） StrInsert  ( HString  &S, int pos,  HString  T) ——在串 S 的第 pos 个 字符之前插入串 T 。 1 ≤  pos  ≤ StrLength (S)+1 。利用 SubString () 和 Concat () 实现。 （ 5 ） StrDelete ( HString  &S, int pos, int  len ) ——删除串 S 中从第 pos 个 字符开始连续的 len 个 字符。 1 ≤  pos  ≤ StrLength (S)-len+1 ，利用 SubString () 和 Concat () 实现。 编写一个主函数 main() ，检验上述操作函数是否正确，实现以下操作： （ 1 ）数据准备。利用 StrAssign () 将设定的字符串常量（自行设定）赋给 3 个字符串变量 T1,T2,T3 ，然后利用 StrTraverse () 输出字符串字符。 （ 2 ）利用 StrCopy () 将串 T1 赋给串 S ，并输出 S 的字符。 （ 3 ）利用 StrInsert () 将串 T2 插入到 S 的尾部，并输出 S 的字符。 （ 4 ）利用 StrReplace () 将串 S 中的 T1 替换成 T3 ，并输出 S 的字符。 （ 5 ）利用 Index() 查找串 T2 在 S 中的位置，并输出位置结果。 （ 6 ）利用 StrDelete () 删除 S 中子串 T2 ，并输出删除后 S 的结果。 2.  源程序代码（ *.CPP ） 见附件  1 . 4 -main.cpp   （见附件） 3.  运行结果 （ 1 ）数据准备。利用 StrAssign () 将设定的字符串常量（自行设定）赋给 3 个字符串变量 T1,T2,T3 ，然后利用 StrTraverse () 输出字符串字符。 利用 StrCopy () 将串 T1 赋给串 S ，并输出 S 的字符。 （ 3 ）利用 StrInsert () 将串 T2 插入到 S 的尾部，并输出 S 的字符。 利用 StrReplace () 将串 S 中的 T1 替换成 T3 ，并输出 S 的字符。 利用 Index() 查找串 T2 在 S 中的位置，并输出位置结果。 利用 StrDelete () 删除 S 中子串 T2 ，并输出删除后 S 的结果